name: Build and Deploy to TestFlight

on:
  push:
    branches:
      - main
      - claude/pull-main-testflight-build-XFEMI
      - claude/sync-upstream-pr-X8ESW
  # Allow manual trigger
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: false
        default: 'build'
        type: choice
        options:
          - build
          - patch
          - minor

permissions:
  contents: write

jobs:
  build-and-deploy:
    runs-on: macos-26

    env:
      SCHEME: OpenClaw
      PROJECT: OpenClaw.xcodeproj

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install pnpm dependencies
        run: pnpm install --frozen-lockfile

      - name: Select Xcode version
        run: |
          # Swift packages require tools version 6.2 → needs Xcode 26+
          if [ -d "/Applications/Xcode_26.0.app" ]; then
            sudo xcode-select -s /Applications/Xcode_26.0.app/Contents/Developer
          elif [ -d "/Applications/Xcode_26.app" ]; then
            sudo xcode-select -s /Applications/Xcode_26.app/Contents/Developer
          elif [ -d "/Applications/Xcode.app" ]; then
            XCODE_VERSION=$(xcodebuild -version | head -1 | awk '{print $2}' | cut -d. -f1)
            if [ "$XCODE_VERSION" -ge 26 ]; then
              sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
            else
              echo "ERROR: Xcode 26+ required (Swift tools 6.2), found Xcode $XCODE_VERSION"
              exit 1
            fi
          else
            echo "ERROR: Xcode not found"
            exit 1
          fi
          xcodebuild -version
          xcodebuild -runFirstLaunch || true

      - name: Download iOS and watchOS platforms
        run: |
          for platform in iOS watchOS; do
            for i in 1 2 3; do
              echo "Attempt $i: Downloading $platform platform..."
              if xcodebuild -downloadPlatform $platform; then
                echo "$platform platform downloaded successfully"
                break
              fi
              [ $i -lt 3 ] && sleep 30
            done
          done

      - name: Install xcodegen and fastlane
        run: brew install xcodegen fastlane swiftlint swiftformat

      - name: Configure signing
        env:
          IOS_DEVELOPMENT_TEAM: ${{ secrets.APPLE_TEAM_ID }}
          BUNDLE_ID: ${{ secrets.OPENCLAW_BUNDLE_ID }}
        run: |
          CONFIG="apps/ios/.local-signing.xcconfig"
          cat > "$CONFIG" <<EOF
          // Auto-generated by CI — do not commit
          OPENCLAW_DEVELOPMENT_TEAM = ${IOS_DEVELOPMENT_TEAM}
          OPENCLAW_IOS_SELECTED_TEAM = ${IOS_DEVELOPMENT_TEAM}
          OPENCLAW_CODE_SIGN_STYLE = Automatic
          // Clear hardcoded profile names so automatic signing picks the right ones
          OPENCLAW_APP_PROFILE =
          OPENCLAW_SHARE_PROFILE =
          EOF
          # Override bundle ID if provided (defaults to ai.openclaw.ios from project.yml)
          if [ -n "${BUNDLE_ID}" ]; then
            echo "OPENCLAW_APP_BUNDLE_ID = ${BUNDLE_ID}" >> "$CONFIG"
            echo "OPENCLAW_SHARE_BUNDLE_ID = ${BUNDLE_ID}.share" >> "$CONFIG"
            echo "OPENCLAW_WATCH_COMPANION_BUNDLE_ID = ${BUNDLE_ID}" >> "$CONFIG"
            echo "OPENCLAW_WATCH_APP_BUNDLE_ID = ${BUNDLE_ID}.watchkitapp" >> "$CONFIG"
            echo "OPENCLAW_WATCH_EXTENSION_BUNDLE_ID = ${BUNDLE_ID}.watchkitapp.extension" >> "$CONFIG"
          fi
          echo "=== Signing config ==="
          cat "$CONFIG"

      - name: Generate Xcode project
        working-directory: apps/ios
        run: xcodegen generate

      - name: Install App Store Connect API Key
        env:
          API_KEY_BASE64: ${{ secrets.APPSTORE_API_KEY_BASE64 }}
          API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
        run: |
          mkdir -p ~/private_keys
          echo "$API_KEY_BASE64" | base64 --decode > ~/private_keys/AuthKey_${API_KEY_ID}.p8

      - name: Normalize provisioning profile directories
        run: |
          USERDATA_PROFILES="$HOME/Library/Developer/Xcode/UserData/Provisioning Profiles"
          MOBILEDEVICE_PROFILES="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$USERDATA_PROFILES" "$MOBILEDEVICE_PROFILES"
          # Xcode/CI tooling can read/write either path depending on version.
          # Mirror existing profiles, then make MobileDevice point at UserData.
          rsync -a "$MOBILEDEVICE_PROFILES/" "$USERDATA_PROFILES/" || true
          if [ ! -L "$MOBILEDEVICE_PROFILES" ]; then
            rm -rf "$MOBILEDEVICE_PROFILES"
            ln -s "$USERDATA_PROFILES" "$MOBILEDEVICE_PROFILES"
          fi

      - name: Resolve App Store Connect auth mode
        env:
          API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          API_KEY_ISSUER_ID: ${{ secrets.APPSTORE_API_KEY_ISSUER_ID }}
        run: |
          KEY_PATH="${HOME}/private_keys/AuthKey_${API_KEY_ID}.p8"

          make_token() {
            local payload_json="$1"
            PAYLOAD_JSON="$payload_json" KEY_PATH="$KEY_PATH" ruby <<'RUBY'
          require "base64"
          require "json"
          require "openssl"

          key_id = ENV.fetch("API_KEY_ID")
          key_path = ENV.fetch("KEY_PATH")
          payload = JSON.parse(ENV.fetch("PAYLOAD_JSON"))
          header = { "alg" => "ES256", "kid" => key_id, "typ" => "JWT" }

          encode = lambda do |obj|
            data = obj.is_a?(String) ? obj : JSON.generate(obj)
            Base64.urlsafe_encode64(data, padding: false)
          end

          segments = [encode.call(header), encode.call(payload)]
          signing_input = segments.join(".")
          key = OpenSSL::PKey.read(File.read(key_path))
          der_signature = key.dsa_sign_asn1(OpenSSL::Digest::SHA256.digest(signing_input))
          asn1 = OpenSSL::ASN1.decode(der_signature)
          r = asn1.value[0].value.to_s(16).rjust(64, "0")
          s = asn1.value[1].value.to_s(16).rjust(64, "0")
          raw_signature = [r + s].pack("H*")
          segments << Base64.urlsafe_encode64(raw_signature, padding: false)
          puts segments.join(".")
          RUBY
          }

          check_token() {
            local token="$1"
            local out="$2"
            curl -sS -o "$out" -w "%{http_code}" \
              -H "Authorization: Bearer ${token}" \
              "https://api.appstoreconnect.apple.com/v1/apps?limit=1"
          }

          now=$(date +%s)
          auth_mode=""
          effective_issuer=""
          auth_body="$(mktemp)"

          if [ -n "${API_KEY_ISSUER_ID}" ]; then
            team_payload=$(printf '{"iss":"%s","exp":%d,"aud":"appstoreconnect-v1"}' "${API_KEY_ISSUER_ID}" "$((now + 1200))")
            team_token="$(make_token "$team_payload")"
            team_status="$(check_token "$team_token" "$auth_body")"
            if [ "$team_status" = "200" ]; then
              auth_mode="team"
              effective_issuer="${API_KEY_ISSUER_ID}"
            else
              echo "Team-key auth probe returned HTTP ${team_status}."
            fi
          fi

          if [ -z "$auth_mode" ]; then
            individual_payload=$(printf '{"sub":"user","exp":%d,"aud":"appstoreconnect-v1"}' "$((now + 1200))")
            individual_token="$(make_token "$individual_payload")"
            individual_status="$(check_token "$individual_token" "$auth_body")"
            if [ "$individual_status" = "200" ]; then
              auth_mode="individual"
              effective_issuer=""
            else
              echo "::error::App Store Connect auth failed for both team and individual token modes."
              echo "Team-key issuer secret may be wrong, or this API key is missing required access."
              cat "$auth_body"
              exit 1
            fi
          fi

          echo "ASC_AUTH_MODE=${auth_mode}" >> "$GITHUB_ENV"
          echo "ASC_EFFECTIVE_ISSUER_ID=${effective_issuer}" >> "$GITHUB_ENV"
          echo "Using App Store Connect auth mode: ${auth_mode}"

      - name: Ensure certificate capacity
        env:
          API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          API_KEY_ISSUER_ID: ${{ env.ASC_EFFECTIVE_ISSUER_ID }}
          ASC_AUTH_MODE: ${{ env.ASC_AUTH_MODE }}
        run: |
          KEY_PATH="${HOME}/private_keys/AuthKey_${API_KEY_ID}.p8"

          make_token() {
            local payload_json="$1"
            local now
            now=$(date +%s)
            if [ "${ASC_AUTH_MODE}" = "individual" ] || [ -z "${API_KEY_ISSUER_ID}" ]; then
              payload_json=$(printf '{"sub":"user","exp":%d,"aud":"appstoreconnect-v1"}' "$((now + 1200))")
            else
              payload_json=$(printf '{"iss":"%s","exp":%d,"aud":"appstoreconnect-v1"}' "${API_KEY_ISSUER_ID}" "$((now + 1200))")
            fi
            PAYLOAD_JSON="$payload_json" KEY_PATH="$KEY_PATH" ruby <<'RUBY'
          require "base64"
          require "json"
          require "openssl"

          key_id = ENV.fetch("API_KEY_ID")
          key_path = ENV.fetch("KEY_PATH")
          payload = JSON.parse(ENV.fetch("PAYLOAD_JSON"))
          header = { "alg" => "ES256", "kid" => key_id, "typ" => "JWT" }

          encode = lambda do |obj|
            data = obj.is_a?(String) ? obj : JSON.generate(obj)
            Base64.urlsafe_encode64(data, padding: false)
          end

          segments = [encode.call(header), encode.call(payload)]
          signing_input = segments.join(".")
          key = OpenSSL::PKey.read(File.read(key_path))
          der_signature = key.dsa_sign_asn1(OpenSSL::Digest::SHA256.digest(signing_input))
          asn1 = OpenSSL::ASN1.decode(der_signature)
          r = asn1.value[0].value.to_s(16).rjust(64, "0")
          s = asn1.value[1].value.to_s(16).rjust(64, "0")
          raw_signature = [r + s].pack("H*")
          segments << Base64.urlsafe_encode64(raw_signature, padding: false)
          puts segments.join(".")
          RUBY
          }

          TOKEN="$(make_token)"

          # Query iOS development certificates
          certs_json="$(mktemp)"
          status=$(curl -sS -o "$certs_json" -w "%{http_code}" \
            -H "Authorization: Bearer ${TOKEN}" \
            "https://api.appstoreconnect.apple.com/v1/certificates?filter%5BcertificateType%5D=IOS_DEVELOPMENT&limit=200")

          if [ "$status" != "200" ]; then
            echo "Warning: could not list certificates (HTTP ${status}), continuing anyway..."
            cat "$certs_json"
            exit 0
          fi

          cert_count=$(jq '.data | length' "$certs_json")
          echo "Found ${cert_count} iOS development certificate(s)"

          # Apple allows max 5 iOS development certs; revoke oldest if at limit
          if [ "$cert_count" -ge 5 ]; then
            # Sort by expiration date ascending and pick the oldest
            oldest_id=$(jq -r '[.data | sort_by(.attributes.expirationDate)] | first | .id' "$certs_json")
            oldest_name=$(jq -r '[.data | sort_by(.attributes.expirationDate)] | first | .attributes.name' "$certs_json")
            echo "Revoking oldest certificate: ${oldest_name} (${oldest_id})"
            revoke_status=$(curl -sS -o /dev/null -w "%{http_code}" -X DELETE \
              -H "Authorization: Bearer ${TOKEN}" \
              "https://api.appstoreconnect.apple.com/v1/certificates/${oldest_id}")
            if [ "$revoke_status" = "204" ] || [ "$revoke_status" = "200" ]; then
              echo "Successfully revoked certificate ${oldest_id}"
            else
              echo "Warning: failed to revoke certificate (HTTP ${revoke_status}), continuing anyway..."
            fi
          else
            echo "Certificate count (${cert_count}) is below limit, no revocation needed"
          fi

      - name: Archive app
        working-directory: apps/ios
        env:
          API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          API_KEY_ISSUER_ID: ${{ env.ASC_EFFECTIVE_ISSUER_ID }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          USERDATA_PROFILES="$HOME/Library/Developer/Xcode/UserData/Provisioning Profiles"
          MOBILEDEVICE_PROFILES="$HOME/Library/MobileDevice/Provisioning Profiles"
          AUTH_ARGS=(
            -authenticationKeyPath "$HOME/private_keys/AuthKey_${API_KEY_ID}.p8"
            -authenticationKeyID "$API_KEY_ID"
          )
          if [ -n "${API_KEY_ISSUER_ID}" ]; then
            AUTH_ARGS+=(-authenticationKeyIssuerID "$API_KEY_ISSUER_ID")
          fi
          for attempt in 1 2 3; do
            echo "Archive attempt ${attempt}/3"
            if xcodebuild archive \
              -project $PROJECT \
              -scheme $SCHEME \
              -configuration Release \
              -archivePath build/OpenClaw.xcarchive \
              -destination "generic/platform=iOS" \
              -allowProvisioningUpdates \
              "${AUTH_ARGS[@]}" \
              CODE_SIGN_STYLE=Automatic \
              DEVELOPMENT_TEAM=$IOS_DEVELOPMENT_TEAM
            then
              break
            fi
            if [ "$attempt" -eq 3 ]; then
              exit 1
            fi
            echo "Archive attempt ${attempt} failed; resync provisioning profile directories and retry..."
            mkdir -p "$USERDATA_PROFILES" "$MOBILEDEVICE_PROFILES"
            rsync -a "$MOBILEDEVICE_PROFILES/" "$USERDATA_PROFILES/" || true
            rsync -a "$USERDATA_PROFILES/" "$MOBILEDEVICE_PROFILES/" || true
            sleep 30
          done

      - name: Prepare distribution signing assets
        working-directory: apps/ios
        env:
          API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          API_KEY_ISSUER_ID: ${{ env.ASC_EFFECTIVE_ISSUER_ID }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.APPLE_TEAM_ID }}
          BUNDLE_ID: ${{ secrets.OPENCLAW_BUNDLE_ID }}
          ASC_AUTH_MODE: ${{ env.ASC_AUTH_MODE }}
        run: |
          API_KEY_JSON="$HOME/private_keys/asc_api_key.json"
          if [ -n "${API_KEY_ISSUER_ID}" ]; then
            jq -n \
              --arg key_id "${API_KEY_ID}" \
              --arg issuer_id "${API_KEY_ISSUER_ID}" \
              --rawfile key "${HOME}/private_keys/AuthKey_${API_KEY_ID}.p8" \
              '{key_id: $key_id, issuer_id: $issuer_id, key: $key, in_house: false}' > "$API_KEY_JSON"
          else
            jq -n \
              --arg key_id "${API_KEY_ID}" \
              --rawfile key "${HOME}/private_keys/AuthKey_${API_KEY_ID}.p8" \
              '{key_id: $key_id, key: $key, in_house: false}' > "$API_KEY_JSON"
          fi

          APP_ID="${BUNDLE_ID:-ai.openclaw.ios}"

          asc_token() {
            local payload_json now
            now=$(date +%s)
            if [ "${ASC_AUTH_MODE}" = "individual" ] || [ -z "${API_KEY_ISSUER_ID}" ]; then
              payload_json=$(printf '{"sub":"user","exp":%d,"aud":"appstoreconnect-v1"}' "$((now + 1200))")
            else
              payload_json=$(printf '{"iss":"%s","exp":%d,"aud":"appstoreconnect-v1"}' "${API_KEY_ISSUER_ID}" "$((now + 1200))")
            fi
            PAYLOAD_JSON="$payload_json" ruby <<'RUBY'
          require "base64"
          require "json"
          require "openssl"

          key_id = ENV.fetch("API_KEY_ID")
          key_path = File.join(ENV.fetch("HOME"), "private_keys", "AuthKey_#{key_id}.p8")
          payload = JSON.parse(ENV.fetch("PAYLOAD_JSON"))
          header = { "alg" => "ES256", "kid" => key_id, "typ" => "JWT" }

          encode = lambda do |obj|
            data = obj.is_a?(String) ? obj : JSON.generate(obj)
            Base64.urlsafe_encode64(data, padding: false)
          end

          segments = [encode.call(header), encode.call(payload)]
          signing_input = segments.join(".")
          key = OpenSSL::PKey.read(File.read(key_path))
          der_signature = key.dsa_sign_asn1(OpenSSL::Digest::SHA256.digest(signing_input))
          asn1 = OpenSSL::ASN1.decode(der_signature)
          r = asn1.value[0].value.to_s(16).rjust(64, "0")
          s = asn1.value[1].value.to_s(16).rjust(64, "0")
          raw_signature = [r + s].pack("H*")
          segments << Base64.urlsafe_encode64(raw_signature, padding: false)
          puts segments.join(".")
          RUBY
          }

          ASC_TOKEN="$(asc_token)"

          ensure_bundle_id() {
            local ident="$1"
            local name="$2"
            local response_file status existing payload
            response_file="$(mktemp)"
            status=$(
              curl -sS -o "$response_file" -w "%{http_code}" -G "https://api.appstoreconnect.apple.com/v1/bundleIds" \
                -H "Authorization: Bearer ${ASC_TOKEN}" \
                --data-urlencode "filter[identifier]=${ident}" \
                --data-urlencode "limit=1"
            )
            if [ "$status" = "401" ] || [ "$status" = "403" ]; then
              echo "::error::App Store Connect API key is not authorized for bundle ID management."
              echo "Grant this key access to Certificates, IDs & Profiles, and verify team/issuer settings."
              cat "$response_file"
              exit 1
            fi
            if [ "$status" != "200" ]; then
              echo "::error::Failed to query bundle ID ${ident} (HTTP ${status})."
              cat "$response_file"
              exit 1
            fi
            existing="$(jq -r '.data[0].id // empty' "$response_file")"
            if [ -n "$existing" ]; then
              echo "Bundle ID exists: ${ident} (${existing})"
              return
            fi
            payload=$(jq -n --arg ident "$ident" --arg name "$name" \
              '{data:{type:"bundleIds",attributes:{identifier:$ident,name:$name,platform:"IOS"}}}')
            status=$(
              curl -sS -o "$response_file" -w "%{http_code}" "https://api.appstoreconnect.apple.com/v1/bundleIds" \
                -H "Authorization: Bearer ${ASC_TOKEN}" \
                -H "Content-Type: application/json" \
                -X POST \
                -d "$payload"
            )
            if [ "$status" = "401" ] || [ "$status" = "403" ]; then
              echo "::error::App Store Connect API key is not authorized to create bundle ID ${ident}."
              cat "$response_file"
              exit 1
            fi
            if [ "$status" != "201" ] && [ "$status" != "409" ]; then
              echo "::error::Failed to create bundle ID ${ident} (HTTP ${status})."
              cat "$response_file"
              exit 1
            fi
            echo "Created bundle ID: ${ident}"
          }

          ensure_bundle_id "$APP_ID" "OpenClaw"
          ensure_bundle_id "${APP_ID}.share" "OpenClaw Share"
          ensure_bundle_id "${APP_ID}.watchkitapp" "OpenClaw Watch App"
          ensure_bundle_id "${APP_ID}.watchkitapp.extension" "OpenClaw Watch Extension"

          # Do not force cert/profile generation in CI: Apple enforces
          # a hard cap on active distribution certificates per team.
          # Export step uses automatic signing with provisioning updates.

      - name: Export and upload to TestFlight
        working-directory: apps/ios
        env:
          API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          API_KEY_ISSUER_ID: ${{ env.ASC_EFFECTIVE_ISSUER_ID }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          /usr/libexec/PlistBuddy -c "Clear dict" ExportOptions.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :method string 'app-store'" ExportOptions.plist
          /usr/libexec/PlistBuddy -c "Add :destination string 'export'" ExportOptions.plist
          /usr/libexec/PlistBuddy -c "Add :signingStyle string 'automatic'" ExportOptions.plist
          /usr/libexec/PlistBuddy -c "Add :teamID string '${IOS_DEVELOPMENT_TEAM}'" ExportOptions.plist

          AUTH_ARGS=(
            -authenticationKeyPath "$HOME/private_keys/AuthKey_${API_KEY_ID}.p8"
            -authenticationKeyID "$API_KEY_ID"
          )
          if [ -n "${API_KEY_ISSUER_ID}" ]; then
            AUTH_ARGS+=(-authenticationKeyIssuerID "$API_KEY_ISSUER_ID")
          fi

          for attempt in 1 2 3; do
            echo "Export attempt ${attempt}/3"
            if xcodebuild -exportArchive \
              -archivePath build/OpenClaw.xcarchive \
              -exportOptionsPlist ExportOptions.plist \
              -exportPath build/export \
              -allowProvisioningUpdates \
              "${AUTH_ARGS[@]}"
            then
              break
            fi
            if [ "$attempt" -eq 3 ]; then
              exit 1
            fi
            echo "Export attempt ${attempt} failed; retrying in 30s..."
            sleep 30
          done

          IPA_PATH=$(find build/export -maxdepth 1 -name "*.ipa" -print -quit)
          if [ -z "$IPA_PATH" ]; then
            echo "No IPA found in build/export after exportArchive."
            exit 1
          fi
          echo "IPA ready: $IPA_PATH"

          UPLOAD_ARGS=(--upload-app --type ios --file "$IPA_PATH" --apiKey "$API_KEY_ID")
          if [ -n "${API_KEY_ISSUER_ID}" ]; then
            UPLOAD_ARGS+=(--apiIssuer "$API_KEY_ISSUER_ID")
          fi

          for attempt in 1 2 3; do
            echo "Upload attempt ${attempt}/3"
            upload_log="$(mktemp)"
            set +e
            xcrun altool "${UPLOAD_ARGS[@]}" 2>&1 | tee "$upload_log"
            altool_status=${PIPESTATUS[0]}
            set -e
            if [ "$altool_status" -eq 0 ] && ! grep -Eq "UPLOAD FAILED|Validation failed \\(409\\)|Failed to upload package" "$upload_log"; then
              break
            fi
            if [ "$attempt" -eq 3 ]; then
              exit 1
            fi
            echo "Upload attempt ${attempt} failed; retrying in 30s..."
            sleep 30
          done

      - name: Clean up API key
        if: always()
        env:
          API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
        run: rm -f ~/private_keys/AuthKey_${API_KEY_ID}.p8 || true

      - name: Summary
        run: |
          echo "## TestFlight Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The build has been uploaded to TestFlight and will be available after Apple processes it (5-30 minutes)." >> $GITHUB_STEP_SUMMARY
